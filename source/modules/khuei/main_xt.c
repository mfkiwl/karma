/*  main_xt.c

    Main file for  khuei  (X11 24bit Huei/Intensity display tool for Karma).

    Copyright (C) 1996  Simone Magri
    Incorporated into Karma by permission.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

    Simone Magri may be reached by email at  smagri@atnf.csiro.au
    Richard Gooch may be reached by email at  karma-request@atnf.csiro.au
    The postal address is:
      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.
*/


/* khuei allows the user to load two files; all the values in each
  file are scaled to the range 0-255; these values are merged into one
  array and used as an index to a colourmap.  The colourmap of 2^16
  values is generated by the user given values of Hue, Intensity, and
  Saturation.
   
  The program by DEFAULT assumes that file1 data contains amplitude
  values and file2 phase values.  However, (real, imaginary) raw data
  files are also supported.  For each of these the file order can also
  be reversed, giving two other modes of operation.
  
  For any given mode you are able to reset the slider values to their
  default values.  */




/* 
   MODIFICATIONS 

   19may96	use viewable images to create and manage the colour wedge
   06jun96	use viewable images to create and manage the image canvas

*/

 


/* This module contains Xt interface code */

#include <stdio.h>
#include <unistd.h>
#include <math.h>
#include <errno.h>
#include <sys/time.h>
#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Form.h>
#include <karma.h>
#include <karma_viewimg.h>
#include <karma_foreign.h>
#include <karma_iarray.h>
#include <karma_kcmap.h>
#include <karma_conn.h>
#include <karma_dir.h>
#include <karma_chx.h>
#include <karma_col.h>
#include <karma_im.h>
#include <karma_a.h>
#include <Xkw/ExclusiveMenu.h>
#include <Xkw/Filepopup.h>
#include <Xkw/Filewin.h>
#include <Xkw/MultiCanvas.h>
#include <Xkw/Value.h>
#include <Xkw/SimpleSlider.h>

/* slider initializations */
#define SLIDER_MIN 0
#define SLIDER_MAX 100
#define SLIDER_HUE_MAX 99

/* identifiers for which widget has just been actived */
#define FILE1 1
#define FILE2 2
#define SHSLD 3
#define EHSLD 4
#define MISLD 5
#define SSLD 6

/* Number of Raw Data Forms the  program can deal with; that is, (File1,File2)
   can be one of RDF_NUM forms and be mapped to (Intensity, Hue) */
#define RDF_NUM 4

/* symbolic constants to identify Raw Data Form of FILE1_FILE2 ( That are
   mapped to INT_HUE respectively */

#define AMP_PHS 0
#define PHS_AMP 1
#define RE_IM 2
#define IM_RE 3
	
/* Private functions */


STATIC_FUNCTION (void fileselect_cbk, (Widget w, XtPointer client_data,
				       XtPointer call_data) );

STATIC_FUNCTION (flag dirselect_cbk,
                 (Widget w, void *info, CONST char *dirname) );

STATIC_FUNCTION (void process_file, (void) );

STATIC_FUNCTION (void popup_cbk, (Widget w, XtPointer client_data,
				  XtPointer call_data) );

STATIC_FUNCTION (void whichfilesel_cbk, (Widget w, XtPointer client_data,
					 XtPointer call_data) );

STATIC_FUNCTION (void reset_cbk, (Widget w, XtPointer client_data,
				  XtPointer call_data) );

STATIC_FUNCTION (void rdf_cbk, (Widget w, XtPointer client_data,
				XtPointer call_data) );

STATIC_FUNCTION (void quit_cbk, (Widget w, XtPointer client_data,
				 XtPointer call_data) );

STATIC_FUNCTION (void slider_cbk, (Widget w, XtPointer client_data,
				   XtPointer call_data) );

STATIC_FUNCTION (flag load_in_iarray, (CONST char *inp_file) );

STATIC_FUNCTION (flag accept_file, (KFileInfo finfo) );

STATIC_FUNCTION (void data_to_huei_pixmap, (void) );

STATIC_FUNCTION (void map_re_im_2_amp_phs, (iarray *re_chan, iarray *im_chan));

STATIC_FUNCTION (void re_im_2_amp_phs,
		 (double re, double im, double *amp, double *phs));

STATIC_FUNCTION (void data_to_16bit, (iarray *amp_data, iarray *phs_data) );

STATIC_FUNCTION (void plot_huei, (void) );

STATIC_FUNCTION (void disp_cwedge_init_imag, (void) );

/* STATIC_FUNCTION is portable across different platforms */



/*  Private data  */

String fallback_resources[] =
{
    "Khuei.geometry:				     -0+0",
    "Khuei*Command*background:                       grey70",
    "Khuei*closeButton*background:                   grey90",
    "Khuei*topForm*quit*background:                  orange",
    "Khuei*background:                               MediumAquamarine",
    "Khuei*font:                                     8x13bold",
    "Khuei*Canvas*background:                        black",
    "Khuei*Canvas*foreground:                        white",
    "Khuei*ExclusiveMenu.background:                 turquoise",
    "Khuei*SimpleSlider.foreground:                  sea green",
    NULL
};

/* define/declare global widgets */
static Widget main_shell = NULL;
static Widget image_canvas = NULL;
static Widget cwedge_canvas = NULL;
static Widget start_hue_sld,end_hue_sld,min_int_sld,sat_sld;


/* implicit external definitions (alloc storage)
   and declarations (nature of variable stated)*/
/* statics only available in this file/local */
/* note: explicit dec with def in fn, like:*/
/* extern int curr_file_selected; */

/* dimensions of array of values in file1 indicates which button was last
   activated, file1 or file2; */
int curr_file_selected;		

/* flags for indicating which file/s have been selected to date */
flag file1selected = FALSE;		
flag file2selected = FALSE;
		   
/* flags for indicating which file/s have been reselected/ reloaded since the
   initial selections */
flag file1_reloaded = FALSE;
flag file2_reloaded = FALSE;

/* Set-up an indicator for when: the first pair of raw data files,
   having an equal number of data values, have been loaded; and all
   iarrays have been created once.  This is useful in a number of
   circumstances of program function */
flag done_once = FALSE;


/* Essentially indicates if a refresh event has occured, thus the image/plot
   needs to be updated. */
flag image_changed = FALSE;
flag called_plot_huei_once = FALSE;

/* if file1 and file2 haven't the same dimensions, no plotting is done */
flag f1f2_same_dim = FALSE;

iarray raw_chan1;	/* intelligent array of file1 data values */
iarray raw_chan2;	/* intelligent array of file2 data values */

/* amp_data and phs_data are merged to form the 16bit array, essentially
   amp_data is mapped to Intensity and phs_data is mapped to Hue */
iarray amp_data, phs_data;


/* 8bit iarrays of channel data; read from files and possibly converted */
iarray amp_8bit, phs_8bit;

/* iarrays that have been created from raw_chan1 and raw_chan2 being
   converted from (real,imaginary) values and vice versa to (amplitude,phase)
   values */
iarray conv_amp_data, conv_phs_data;

/* 16bit iarray merged from the two 8bit scaled channel/file data iarrays */ 
iarray merge_16bit;

/* selected start hue range value selected */
int start_hue_val = SLIDER_MIN;

/* selected end hue range value selected */
int end_hue_val = SLIDER_HUE_MAX;

/* selected minimum intensity range value, maximum intensity is fixed by
   colourmap creation routine */
int min_int_val = SLIDER_MIN;

/* selected saturation slider value */
int sat_val = SLIDER_MAX;

/* dimensions of array of values in file1 */
static unsigned long length_data_chan1[2] = {0,0};  

/* dimensions of array of values in file2 */
static unsigned long length_data_chan2[2] = {0,0};

/* rgb masks for the graphics system/ display; array of transformed rgb
   values of colourmap with the given masks */
unsigned long red_mask,green_mask,blue_mask,rgb_array[65536];

/* most significant (y, greatest stride in memory) and least significant
   dimensions of channel data iarrays*/
unsigned long most_sig_dim, least_sig_dim;

/* The pixel canvases of the true canvas widgets of the image and
   colour-wedge */
static KPixCanvas imag_pix_true_cnvs, cwedge_pix_true_cnvs;

/* image (pixel) dimensions for CURRENT user selected program parameters */
int x_pixels, y_pixels;

/* image (pixel) dimensions for the LAST user selected program parameters */
  int last_x_pixels, last_y_pixels; 
  
/* Number of Raw Data Forms that the program can deal with; map to Intensity
 vs Hue */
/* const unsigned int rdf_num = 2; - doesn't work for externa/static vars*/

/* array holding Raw Data Form id's is initialized */
/* alternative def - doesn't work*/
/* char rdf_str[RDF_NUM][1] =
{ { "Amp, Phs" }, { "Phs, Amp"}, { "Re, Im" }, { "Im, Re" } }; */

/* works def */
char *rdf_str[RDF_NUM] =
{ "Amplitude, Phase", "Phase, Amplitude",
  "Real, Imaginary", "Imaginary, Real" };

/* Indicates the current user selected form of the RAW data, default is
   (Amplitude, Phase) */
unsigned int rdf_id = 0;

/* cmap_rgb_array points to a 65536 value (2^16) Karma PseudoColourmap,
   cmap. */
Kcolourmap cmap;
unsigned long *cmap_rgb_array;
KWorldCanvas imag_world_cnvs;

/* Scaled values of hue, intensity and saturation; scaling is based on the
   current % slider values. */
const float max_int = 1.0;
float start_hue,end_hue,min_int,sat;

    

main(argc, argv)
int argc;
char **argv;
{
    XtAppContext app_context;
    Display *dpy;
    Screen *screen;
    Widget topform;
    Widget filepopup, file1_btn, file2_btn;
    Widget reset_btn;
    Widget quit_btn;
    Widget image_canvas;
    Widget cwedge_canvas;
    Widget imag_true_cnvs;
    Widget cwedge_true_cnvs;
    Widget filewin;
    Widget rdf_menu_btn;
    int canvas_types;
    int image_cnvs_init_siz = 512;
    const int cwedge_width = 256;
    const int cwedge_height = 64;


/*  Start up Xt  */   

    main_shell = XtVaAppInitialize (&app_context, "Khuei",
				    NULL, 0,
				    &argc, argv, fallback_resources,
				    NULL, 0);


/*  Initialise communications  */ 

    chx_register_app_context (app_context);
    conn_register_managers (chx_manage, chx_unmanage, ( void (*) () ) NULL);
    dpy = XtDisplay (main_shell);
    screen = XtScreen (main_shell);
    

/*  Create other widgets  */

/* PARENT Form widget - main shell */
    topform = XtVaCreateManagedWidget ("topForm", formWidgetClass, main_shell,
				       XtNhSpace, 0,
				       XtNborderWidth, 0,
				       NULL);
/* Command widgets */
    filepopup = XtVaCreatePopupShell ("filewinPopup", filepopupWidgetClass,
				      main_shell,
				      XkwNfilenameTester, accept_file,
				      XtNtitle, "khuei File Selector",
				      XtNx, 0,
				      XtNy, 0,
				      XkwNautoPopdown, True,
				      NULL);
    XtAddCallback (filepopup, XkwNfileSelectCallback, fileselect_cbk,NULL);
    filewin = XtNameToWidget (filepopup, "form.selector");
    (void) XkwFilewinRegisterDirCbk (filewin,dirselect_cbk,(Widget) filepopup);


    file1_btn = XtVaCreateManagedWidget ("button", commandWidgetClass,
					 topform, 
					 XtNlabel, "File1",
					 XtNtop, XtChainTop,
					 XtNbottom, XtChainTop,
					 XtNleft, XtChainLeft,
					 XtNright, XtChainLeft,
					 NULL);
    XtAddCallback(file1_btn, XtNcallback, popup_cbk, filepopup);
    XtAddCallback(file1_btn, XtNcallback, whichfilesel_cbk, (XtPointer) FILE1);

    file2_btn = XtVaCreateManagedWidget ("button", commandWidgetClass,
					 topform,
					 XtNlabel, "File2",
					 XtNfromHoriz, file1_btn,
					 XtNtop, XtChainTop,
					 XtNbottom, XtChainTop,
					 XtNleft, XtChainLeft,
					 XtNright, XtChainLeft,
					 NULL);
    XtAddCallback(file2_btn, XtNcallback, popup_cbk, filepopup);
    XtAddCallback(file2_btn, XtNcallback, whichfilesel_cbk, (XtPointer) FILE2);


    reset_btn = XtVaCreateManagedWidget ("button", commandWidgetClass,
					 topform,
					 XtNlabel, "Reset",
					 XtNfromHoriz, file2_btn,
					 XtNtop, XtChainTop,
					 XtNbottom, XtChainTop,
					 XtNleft, XtChainLeft,
					 XtNright, XtChainLeft,
					 NULL);
    XtAddCallback (reset_btn, XtNcallback, reset_cbk, NULL);

    
/* ExclusiveMenu Widget */
    rdf_menu_btn = XtVaCreateManagedWidget ("menuButton",
					    exclusiveMenuWidgetClass,
					    topform,
					    XtNmenuName, "rdfMenu",
					    XtNfromVert, file1_btn,
					    XkwNchoiceName,
					    "RAW DATA FORM (File1, File2) ",
					    XtNfromVert, file2_btn,
					    XtNtop, XtChainTop,
					    XtNbottom, XtChainTop,
					    XtNleft, XtChainLeft,
					    XtNright, XtChainLeft,
					    XkwNnumItems, RDF_NUM,
					    XkwNitemStrings, rdf_str,
					    NULL);
    XtAddCallback (rdf_menu_btn, XkwNselectCallback, rdf_cbk, NULL);


/* Command Widget */
    quit_btn = XtVaCreateManagedWidget ("quit", commandWidgetClass, topform,
					XtNlabel, "Quit",
					XtNfromHoriz, reset_btn,
					XtNtop, XtChainTop,
					XtNbottom, XtChainTop,
					XtNleft, XtChainLeft,
					XtNright, XtChainLeft,
					NULL);
    XtAddCallback (quit_btn, XtNcallback, quit_cbk, NULL);


/* Value widgets */
    start_hue_sld = XtVaCreateManagedWidget ("slider", simpleSliderWidgetClass,
					     topform,
					     XtNlabel, "% Start Hue",
					     XtNfromVert, rdf_menu_btn,
					     XtNborderWidth, 0,
					     XtNorientation, XtorientVertical,
					     XtNtop, XtChainTop,
					     XtNbottom, XtChainTop,
					     XtNleft, XtChainLeft,
					     XtNright, XtChainLeft,
					     XkwNminimum, SLIDER_MIN,
					     XkwNmaximum, SLIDER_HUE_MAX,
					     XkwNmodifier, 1,
					     XtNvalue, SLIDER_MIN,
					     XkwNvaluePtr,&start_hue_val,
					     NULL);
    XtAddCallback (start_hue_sld,XkwNvalueChangeCallback,slider_cbk,
		   (XtPointer) SHSLD);

    end_hue_sld = XtVaCreateManagedWidget ("slider", simpleSliderWidgetClass,
					   topform,
					   XtNlabel, "% End Hue",
					   XtNfromVert, rdf_menu_btn,
					   XtNfromHoriz, start_hue_sld,
					   XtNborderWidth, 0,
					   XtNorientation, XtorientVertical,
					   XtNtop, XtChainTop,
					   XtNbottom, XtChainTop,
					   XtNleft, XtChainLeft,
					   XtNright, XtChainLeft,
					   XkwNminimum, 0,
					   XkwNmaximum, SLIDER_HUE_MAX,
					   XkwNmodifier, 1,
					   XtNvalue, SLIDER_HUE_MAX,
					   XkwNvaluePtr,&end_hue_val,
					   NULL);
    XtAddCallback (end_hue_sld,XkwNvalueChangeCallback,slider_cbk,
		   (XtPointer) EHSLD);

    min_int_sld = XtVaCreateManagedWidget ("slider", simpleSliderWidgetClass, 
					   topform,
					   XtNlabel, "% Min Intensity",
					   XtNfromVert, start_hue_sld,
					   XtNborderWidth, 0,
					   XtNorientation, XtorientVertical,
					   XtNtop, XtChainTop,
					   XtNbottom, XtChainTop,
					   XtNleft, XtChainLeft,
					   XtNright, XtChainLeft,
					   XkwNminimum, SLIDER_MIN,
					   XkwNmaximum, SLIDER_MAX,
					   XkwNmodifier, 1,
					   XtNvalue, SLIDER_MIN,
					   XkwNvaluePtr,&min_int_val,
					   NULL);
    XtAddCallback (min_int_sld,XkwNvalueChangeCallback,slider_cbk,
		   (XtPointer) MISLD);

    sat_sld = XtVaCreateManagedWidget ("slider", simpleSliderWidgetClass,
				       topform,
				       XtNlabel, "% Saturation",
				       XtNfromVert, start_hue_sld,
				       XtNfromHoriz, min_int_sld,
				       XtNborderWidth, 0,
				       XtNorientation, XtorientVertical,
				       XtNtop, XtChainTop,
				       XtNbottom, XtChainTop,
				       XtNleft, XtChainLeft,
				       XtNright, XtChainLeft,
				       XkwNminimum, SLIDER_MIN,
				       XkwNmaximum, SLIDER_MAX,
				       XkwNmodifier, 1,
				       XtNvalue, SLIDER_MAX,
				       XkwNvaluePtr,&sat_val,
				       NULL);
    XtAddCallback (sat_sld,XkwNvalueChangeCallback,slider_cbk,
		   (XtPointer) SSLD);

/* Canvas widgets */


    canvas_types = XkwCanvasTypeTrueColour;

/* colour-wedge pixel canvas */
    cwedge_canvas = XtVaCreateManagedWidget ("multiCanvas",
					     multiCanvasWidgetClass ,
					     topform,
					     XtNfromVert, sat_sld,
					     XtNwidth, cwedge_width,
					     XtNheight, cwedge_height,
					     XkwNcanvasTypes, canvas_types,
					     XtNtop, XtChainTop,
					     XtNbottom, XtChainTop,
					     XtNleft, XtChainLeft,
					     XtNright, XtChainLeft,
					     NULL);
    cwedge_true_cnvs = XtNameToWidget (cwedge_canvas, "trueColourCanvas");
    if (cwedge_true_cnvs == NULL){
      fprintf(stderr,"\n24 bit display Not Supported\n");
      exit (1);
    }

      
    XtVaSetValues (cwedge_true_cnvs,
		   XtNmappedWhenManaged, True,
		   XkwNsilenceUnconsumed, True,
		   NULL);


/* image pixel canvas */
    if (HeightOfScreen(XtScreen(topform)) < 700) image_cnvs_init_siz = 385;
   
    image_canvas = XtVaCreateManagedWidget ("multiCanvas",
					    multiCanvasWidgetClass ,
					    topform,
					    XtNfromVert, cwedge_canvas,
					    XtNwidth, image_cnvs_init_siz,
					    XtNheight, image_cnvs_init_siz ,
					    XkwNcanvasTypes, canvas_types,
					    XtNtop, XtChainTop,
					    XtNbottom, XtChainBottom,
					    XtNleft, XtChainLeft,
					    XtNright, XtChainRight,
					    NULL);
    imag_true_cnvs = XtNameToWidget (image_canvas, "trueColourCanvas");
    if (imag_true_cnvs == NULL){
      fprintf(stderr,"\n24 bit display Not Supported\n");
      exit (1);
    }

      
    XtVaSetValues (imag_true_cnvs,
		   XtNmappedWhenManaged, True,
		   XkwNsilenceUnconsumed, True,
		   NULL);


    XtRealizeWidget (main_shell);
    XtRealizeWidget (filepopup);


    XtVaGetValues(cwedge_true_cnvs,
		  XkwNmonoPixCanvas, &cwedge_pix_true_cnvs,
		  NULL);

    XtVaGetValues(imag_true_cnvs,
		  XkwNmonoPixCanvas, &imag_pix_true_cnvs,
		  NULL);

    disp_cwedge_init_imag();


    XtAppMainLoop (app_context);


}	/*  End Function main */




/*  PRIVATE ROUTINES follow  */

static void popup_cbk (Widget w, XtPointer client_data, XtPointer call_data)

/*  This is the generic popup button callback. */

{

  Widget popup = (Widget) client_data;
  XtPopup (popup, XtGrabNone);

}   /*  End Function popup_cbk   */



static void whichfilesel_cbk (Widget w, XtPointer client_data,
			      XtPointer call_data)

/* Determines which file button has been selected, thus identifies raw
   data as file1 and file2.  This is also done when indicate when
   files have been reloaded. */

{
/* explicit extern */
/*  int curr_file_selected; */
  curr_file_selected = (int) client_data;
  if (curr_file_selected == 1) {
    if (file1selected)
      file1_reloaded = TRUE;
    
    file1selected = TRUE;
  }
  else {
    if (file2selected)
      file2_reloaded = TRUE;
    
    file2selected = TRUE;
  }
  
}   /*  End Function whichfilesel_cbk  */



static void reset_cbk (Widget w, XtPointer client_data, XtPointer call_data)

/* Resets the slider values to their defaults and replots the corresponding
   hue-intensity pixel map. */

{

  XtVaSetValues (start_hue_sld,
		 XtNvalue, SLIDER_MIN,
		 NULL);
  
  XtVaSetValues (end_hue_sld,
		 XtNvalue, SLIDER_HUE_MAX,
		 NULL);
  
  XtVaSetValues (min_int_sld,
		 XtNvalue, SLIDER_MIN,
		 NULL);
  
  XtVaSetValues (sat_sld,
		 XtNvalue, SLIDER_MAX,
		 NULL);
  
  if (file1selected && file2selected){
    if ( (length_data_chan1[0] != length_data_chan2[0]) 
	 || (length_data_chan1[1] != length_data_chan2[1]) ) {
      
      (void) fprintf(stderr, "WARNING:\n");
      fprintf(stderr, "Dimensions of values in File1 and File2 are \
different.\n");
      (void) fprintf(stderr, "Both files MUST have same dimensions to \
produce a pixel map.\n\n");
      return;
    }
    else{
      /* refresh colour-wedge and image canvas */
      plot_huei();
    }
  }
  else{
    /* only refresh colour-wedge */
    /* scale % slider values of hue, intensity and saturation
       for colourmap routine; the sliders allow the user to effectivly
       select a subspace of the full colour space to create the
       colourmap */
    start_hue =  (start_hue_val/100.0) * 6.0;
    end_hue = (end_hue_val/100.0) * 6.0;
    min_int = (min_int_val/100.0) * max_int;
    sat = (sat_val/100.0) * 1.0;
    
    /* Create the RGB colours for the colour-map. This colour-map will
       reflect the users CURRENT choise of: min/max hue, min
       intensity, and saturation. */
    col_hsb_slice_to_rgb_array(cmap_rgb_array,red_mask,green_mask,blue_mask,
			       min_int,max_int,start_hue,end_hue,sat);  
    
    /* invoke refreshing */
    kcmap_notify_pixels_changed (cmap);
  }
  
  
}   /*  End Function reset_cbk   */




static void rdf_cbk (Widget w, XtPointer client_data, XtPointer call_data)

/* Determines the user selection of the Raw Data Form (eg Amp,Phs) and
   uses this to convert the data to hue,intensity mapped pixel map. */

{    
  rdf_id = *(int *) call_data;
  
  
  if (file1selected && file2selected){
    
    if ( (length_data_chan1[0] != length_data_chan2[0]) 
	 || (length_data_chan1[1] != length_data_chan2[1]) ) {
      
      (void) fprintf(stderr, "WARNING:\n");
      fprintf(stderr, "Dimensions of values in File1 and File2 are \
different.\n");
      (void) fprintf(stderr, "Both files MUST have same dimensions to \
produce a pixel map.\n\n");
      return;
    }
    else{
      data_to_huei_pixmap();
    }
    
  }
  else {
    (void) fprintf (stderr, "TWO Files of data must be loaded.\n");  
  }
  
}   /*  End Function rdf_cbk   */



static void quit_cbk (Widget w, XtPointer client_data, XtPointer call_data)

/*  This is the quit button callback, exits from the application. */

{
  exit (RV_OK);
}   /*  End Function quit_cbk   */



static void slider_cbk (w, client_data, call_data)

/*  This is the slider subcube callback. */

     Widget w;
     XtPointer client_data;	/* application data */
     XtPointer call_data;	/* widget value data */
{
  
  /* hue/sat/int slider/s have been activated, values changed */
  
  
  /* obtain new slider values from widget */
  int slider_selected;

  slider_selected = (int) client_data;
  
  switch (slider_selected) {
    case SHSLD:
      start_hue_val = *(int *) call_data;
      break;
    case EHSLD:
      end_hue_val = *(int *) call_data;
      break;
    case MISLD:
      min_int_val = *(int *) call_data;
      break;
    case SSLD:
      sat_val = *(int *) call_data;
      break;
    default:
      break;
  }

  

/* New slider values can't be applied to image canvas unless two files
   have already been loaded that are the same size (equal dimensions).
   Hence, the user is warned and instructed on what should be done. */
  if (file1selected && file2selected){    
    if ( (length_data_chan1[0] != length_data_chan2[0]) 
         || (length_data_chan1[1] != length_data_chan2[1]) ) {
      
      (void) fprintf(stderr, "WARNING:\n");
      fprintf(stderr, "Dimensions of values in File1 and File2 are \
different.\n");
      (void) fprintf(stderr, "Both files MUST have same dimensions to \
produce a pixel map.\n\n");
      return;
    }
    else{
      /* refresh colour-wedge and image canvas */
      plot_huei();
    }
  }
  else{
    /* only refresh colour-wedge */
    plot_huei();
    /* scale % slider values of hue, intensity and saturation
       for colourmap routine; the sliders allow the user to effectivly
       select a subspace of the full colour space to create the
       colourmap */
/*    start_hue =  (start_hue_val/100.0) * 6.0;
    end_hue = (end_hue_val/100.0) * 6.0;
    min_int = (min_int_val/100.0) * max_int;
    sat = (sat_val/100.0) * 1.0;
    
    col_hsb_slice_to_rgb_array(cmap_rgb_array,red_mask,green_mask,blue_mask,
			       min_int,max_int,start_hue,end_hue,sat);  
    
    kcmap_notify_pixels_changed (cmap);
    */
  }
  
  
}   /*  End Function slider_cbk   */




static flag dirselect_cbk (Widget w, void *info, CONST char *dirname)

/* When a directory is selected in the file selector the entire
   directory is 'captured', thus treated as a single file. This is
   useful when a data file is actually implemented as a directory or
   files, such as with Astronomical Data Reduction package Miriad.

   If the directory is not a Miriad data file the normal behaviour
   occurs, where the active directory is changed. */

{
     
  if ( !foreign_miriad_test (dirname) ) return (FALSE);
  
  /* It is a Miriad file. First pop-down the fileselector and
     process the directory as a normal file would be */
  XtPopdown ( (Widget) info );
  XSync (XtDisplay (w), False);
  
  load_in_iarray (dirname);
  (void) fprintf (stderr, "Filename: \"%s\"\n", dirname);
  
  process_file();
  
  return (TRUE);

}    /*  End Function dirselect_cbk  */




static void fileselect_cbk (Widget w, XtPointer client_data,
			    XtPointer call_data)

/*  Loads a single file at a time and processes it. */

{
  
  
  /* name of data file/channel loaded into iarray */ 
  char *filename;
  
  
  /* load in values of iarray into chan?_data intelligent arrays */
  filename = (char *) call_data;
  
  load_in_iarray (filename);
  (void) fprintf (stderr, "Filename: \"%s\"\n", filename);

  process_file();

} /* End Function fileselect_cbk */




static void process_file (void)

/* Detects when two files have been loaded.  Once two have been loaded
  the data is manipulated to create a 16bit index to a colourmap.
  Where the colour space of the colourmap is determined from the user
  selected % range values of Intensity, Hue and Saturation.  By
  default file1 is assumed to be Amplitude data and is mapped to
  Intensity, while, file2 is assumed to be Phase data and is mapped to
  to Hue.  However, appropriate conversions are done if the user
  indicates the data is: Phs,Amp; Re,Im; or Im,Re.  The pixmap of
  (Amplitude,Phase) mapped to (Intensity, Hue) is then plotted.  */

{

  /* calculate and store the dimension lengths of chan1/chan2 data for later */
  if (curr_file_selected == 1) {
    length_data_chan1[0] = iarray_dim_length(raw_chan1,0);
    length_data_chan1[1] = iarray_dim_length(raw_chan1,1);
  }
  else {
    length_data_chan2[0] = iarray_dim_length(raw_chan2,0);
    length_data_chan2[1] = iarray_dim_length(raw_chan2,1);
  }
  
  
/* File reloaded indicators are only used once a set of same dimension/
   legitamate files have been loaded once. */
  
  if (!done_once || !f1f2_same_dim){
    if (file1_reloaded && !file2_reloaded)
      file1_reloaded = FALSE;
    else if (file2_reloaded && !file1_reloaded)
      file2_reloaded = FALSE;
    else{
      file1_reloaded = FALSE;
      file2_reloaded = FALSE;
    }
  }
  
  
  /* continue only if  2 data files have been loaded, otherwise
     prompt the user for another file */   
  if (file1selected && file2selected){

    if (length_data_chan1[0] >= length_data_chan1[1]){
      most_sig_dim = length_data_chan1[0];
      least_sig_dim = length_data_chan1[1];
    }
    else{
      least_sig_dim = length_data_chan1[0];
      most_sig_dim = length_data_chan1[1];
    }
    
    /* If your are creating a new image using only one new file and a file
       used to create the previous image, don't allocate more storage
       for it.
       
       (ASIDE: only if new files are loaded do iarrays have to be
       reallocated and the old versions deallocated, as their
       fundamentaly charictaristics may have changed; for instance, in
       size and type.) */ 
    
    /* reinitialize loaded file traking variables, ready for another
       reload */
    
    /* LATER: this ifblock can be set-up to not do these alloc and deallocs
       if they aren't necessary, ie new/current most_sig_dim and
       least_sig_dim haven't changed from old/previous values, as well
       as the types of the iarrays */
    
/*    if ( (file1_reloaded || file2_reloaded) &&
      (file1selected && file2selected) ){
      */  
    
    if ( file1_reloaded || file2_reloaded ){
      
      if (file1_reloaded && !file2_reloaded){ 
	iarray_dealloc (amp_8bit);
	amp_8bit = iarray_create_2D(most_sig_dim,least_sig_dim,K_UBYTE);
	file1_reloaded = FALSE;
      }
      else if (file2_reloaded && !file1_reloaded){
	iarray_dealloc (phs_8bit);
	phs_8bit = iarray_create_2D(most_sig_dim,least_sig_dim,K_UBYTE);
	file2_reloaded = FALSE;
      }
    }
    else{
      if (done_once){
	iarray_dealloc (amp_8bit);
	iarray_dealloc (phs_8bit);
	iarray_dealloc (conv_amp_data);
	iarray_dealloc (conv_phs_data);
	iarray_dealloc (merge_16bit);
	amp_8bit = iarray_create_2D(most_sig_dim, least_sig_dim, K_UBYTE); 
	phs_8bit = iarray_create_2D(most_sig_dim, least_sig_dim, K_UBYTE); 
	conv_amp_data=iarray_create_2D(most_sig_dim,least_sig_dim, K_DOUBLE);
	conv_phs_data=iarray_create_2D(most_sig_dim,least_sig_dim, K_DOUBLE);
	merge_16bit=iarray_create_2D(most_sig_dim, least_sig_dim, K_USHORT);
      }
      else{
	amp_8bit = iarray_create_2D(most_sig_dim, least_sig_dim, K_UBYTE); 
	phs_8bit = iarray_create_2D(most_sig_dim, least_sig_dim, K_UBYTE); 
	conv_amp_data=iarray_create_2D(most_sig_dim,least_sig_dim,K_DOUBLE);
	conv_phs_data=iarray_create_2D(most_sig_dim,least_sig_dim,K_DOUBLE);
	merge_16bit=iarray_create_2D(most_sig_dim, least_sig_dim, K_USHORT);
/* Indicate that: now for the first time 2 raw data files were
	   loaded, that have the same number of data values; and all
	   iarrays have been created once. */
	if (!done_once){
	  done_once = TRUE;
	}
      }
    }
    
    /* Determine the number of data values in file1 and file2 - warn user
       if values are different and they must be the same to produce a
       pixel map */
        
    if ( (length_data_chan1[0] != length_data_chan2[0]) 
	 || (length_data_chan1[1] != length_data_chan2[1]) ) {
      
      (void) fprintf(stderr, "WARNING:\n");
      fprintf(stderr, "Dimensions of values in File1 and File2 are \
different.\n");
      (void) fprintf(stderr, "Both files MUST have same dimensions to \
produce a pixel map.\n\n");
      f1f2_same_dim = FALSE;
      return;
    }
    else{
      f1f2_same_dim = TRUE;
      data_to_huei_pixmap();
    }
    
  }
  else{
    (void) fprintf (stderr, "ANOTHER File of data must now be loaded.\n"); 
  }
  
} /* End Function process_file */



flag load_in_iarray (CONST char *inp_file)
     
/*  This routine will load a file (supported foreign data format)
    into a 2-dimensional Intelligent array.
    
    Note: the iarrays are allocated when this is done. */
{
  unsigned int ftype;
  multi_array *multi_desc;
  
  /* Load file into iarray and deallocate old ones. */

  if ( ( multi_desc = foreign_guess_and_read (inp_file, K_CH_MAP_LOCAL,
					      FALSE, &ftype,
					      FA_GUESS_READ_END) ) == NULL){
    (void) fprintf (stderr, "Error reading file: \"%s\"\n", inp_file);
    return (FALSE);
  }
  

  if (curr_file_selected == 1){
    if (done_once){
      iarray_dealloc (raw_chan1);
    }

   if (!done_once && file1_reloaded){
       iarray_dealloc (raw_chan1);
   }
    
    (void) fprintf (stderr, "*****    File1    *****\n");
    if ( (raw_chan1 = iarray_get_from_multi_array (multi_desc, NULL, 2,
						   NULL,
						   NULL)) == NULL) {
      (void) fprintf (stderr, "Error extracting file1 2-D \
Intelligent Array\n");
      return (FALSE);
    }
  }
  else{
    if (done_once){
      iarray_dealloc (raw_chan2);
    }

    if (!done_once && file2_reloaded){
	iarray_dealloc (raw_chan2);
    }
    (void) fprintf (stderr, "*****    File2    *****\n");
    if ( (raw_chan2 = iarray_get_from_multi_array (multi_desc, NULL, 2,
						    NULL,
						    NULL)) == NULL) {
      (void) fprintf (stderr, "Error extracting file2 2-D \
Intelligent Array\n");
      return (FALSE);
    }
  }
  
  /* LATER: deallocate multi_desc as it is not needed anymore */

}   /*  End Function load_in_iarray  */



static flag accept_file (KFileInfo finfo)
{
  /*  Accept all directories  */
  if (finfo.type == KFILETYPE_DIRECTORY) return (TRUE);
  switch ( foreign_guess_format_from_filename (finfo.filename) )
  {
    case FOREIGN_FILE_FORMAT_KARMA:
    case FOREIGN_FILE_FORMAT_FITS:
      return (TRUE);
      
    default:
      break;
  }
  /*  Reject everything else  */
  return (FALSE);
} /*  End Function accept_file  */



static void map_re_im_2_amp_phs(iarray *re_chan, iarray *im_chan)
{
  double amp, phs;
  int i,j;		/* counters for accessing array elements */

  
  /* mapping of (Real,Imaginary) raw data iarrays to (Amplitude, Phase)
     iarrays */


  iarray_copy_data( conv_amp_data, *re_chan, FALSE );
  iarray_copy_data( conv_phs_data, *im_chan, FALSE );
  for (i=0; i < most_sig_dim; i++)
    for (j=0; j < least_sig_dim; j++){
      re_im_2_amp_phs(D2(conv_amp_data,i,j),D2(conv_phs_data,i,j),&amp,&phs);
      D2(conv_amp_data,i,j) = amp;
      D2(conv_phs_data,i,j) = phs;
    }
  
} /* End Function map_re_im_2_amp_phs */
	

	       

static void re_im_2_amp_phs (double re, double im, double *amp, double *phs)
{
  const double zero = 0.0;

/* Calculate Amplitude and Phase values fom Real and Imaginary values. */
/* Account for domain error with pow(x, y) function. */
  
  
  if ( (re == zero) && (im == zero) ){
    *amp = zero;
    *phs = zero;
  }
  else if ( (re == zero) && (im != zero)){
    *amp = im;
    *phs = atan2(im,re); 
  }
  else if ( (re != zero) && (im == zero) ){
    *amp = re;
    *phs = atan2(im,re);
  }
  else{
    *amp = sqrt( (pow(re,2) + pow(im,2)) );
    *phs = atan2(im,re);
  }
  
/* since we have a linear mapping of phase values in the 16bit array */
  if ( *phs < zero )
    *phs = TWOPI + *phs;

  
} /* End Function re_im_2_amp_phs */




static void data_to_16bit (iarray *amp_data, iarray *phs_data)
{

  /* The 16bit array created from: scaling to 8bit arrays the two input
     channel data arrays ; and merging the two.  The upper 8bits (MSByte)
     represent scaled Amplitude and the lower 8bits (LSByte) represent
     scaled Phase.  This 16bit array is used as an index to the RGB colour
     map. */
  
  /* The input arrays *must* have already been converted to (Amplitude, Phase),
     and this is *always* mapped to (Intensity, Hue) in the pixmap. */
     
     

  /* scale factor and offset to convert loaded iarrays to
     values in the range 0-255, that is to 8bit values */
  double scale[2], offset[2];
  
  /* minimum and maximum values of channel data */
  double min_amp_data, min_phs_data, max_amp_data, max_phs_data;
  
  /* counters for accessing array elements */
  int i,j;
  
  scale[1] = 0.0;
  offset[1] = 0.0;
  /* (note: conv1_real is ignored unless input values are complex) */
  iarray_min_max (*amp_data,CONV1_REAL,&min_amp_data,&max_amp_data);
  scale[0] = 255 / (max_amp_data - min_amp_data);
  offset[0] = (255 * min_amp_data) / (min_amp_data - max_amp_data);
  iarray_scale_and_offset(amp_8bit, *amp_data, scale, offset, FALSE);
  
  iarray_min_max (*phs_data, CONV1_REAL,&min_phs_data,&max_phs_data);
  scale[0] = 255 / (max_phs_data - min_phs_data);
  offset[0] = (255 * min_phs_data) / (min_phs_data - max_phs_data);
  iarray_scale_and_offset(phs_8bit, *phs_data, scale, offset, FALSE);
  
  for (i=0; i < most_sig_dim; i++)
    for (j=0; j < least_sig_dim; j++)
      US2(merge_16bit,i,j) =
	(  ( ((unsigned short int) UB2(amp_8bit,i,j))  ) << 8  ) ^
	UB2(phs_8bit,i,j);
  

} /* End Function data_to_16bit */




static void plot_huei(void)
{
/* Plots the pixmap of the raw data.  The merge_16bit array is used as an
   index to the colourmap.  The RBG colour map (PseudoColour type) is
   created based on the range of  hues, intensities, and the saturation
   value, selected by the user */


  ViewableImage imag_vimage;


  /* scale % slider values of hue, intensity and saturation
     for colourmap routine; the sliders allow the user to effectivly
     select a subspace of the full colour space to create the
     colourmap */
  start_hue =  (start_hue_val/100.0) * 6.0;
  end_hue = (end_hue_val/100.0) * 6.0;
  min_int = (min_int_val/100.0) * max_int;
  sat = (sat_val/100.0) * 1.0;
  

    
  /* Indicate that a refresh event has occured, plot_huei is always called
     when this occurs. */
  image_changed = TRUE;


/* Refresh COLOUR-WEDGE and IMAGE pixel canvases.  If merge_16bit contains
   non NULL values for the first time the image viewable image is created. */

  if (file1selected && file2selected){
    imag_vimage = viewimg_create_from_iarray (imag_world_cnvs, merge_16bit,
					      FALSE);
    viewimg_make_active (imag_vimage);
  }

  /* calculate current colourmap subspace */
  col_hsb_slice_to_rgb_array(cmap_rgb_array,red_mask,green_mask,blue_mask,
			     min_int,max_int,start_hue,end_hue,sat);  
  
  kcmap_notify_pixels_changed (cmap);
  

}   /*  End Function plot_huei  */
    



static void data_to_huei_pixmap(void)
{


  /* Since raw_chan1 and raw_chan2 have been loaded: if necessary, convert
     this raw data and, or swap the channels the data is stored in; the
     data can then be plotted as a hue_intensity pixmap. */
  
  switch (rdf_id){
    case AMP_PHS:
/* This is the program assumed default form of data - raw channel data
   stored as rawFILE1_rawFILE2;  (Amp,Phs) --> (Intensity,Hue). */
      data_to_16bit(&raw_chan1, &raw_chan2);
      plot_huei();
      break;
      
    case PHS_AMP:
/* Swap raw channel data: rawFILE1 -> FILE2, rawFILE2 -> FILE1;
   (Amp,Phs) --> (Intensity,Hue). */ 
      data_to_16bit(&raw_chan2, &raw_chan1);
      plot_huei();
      break;
      
      case RE_IM:
/* Raw Data Form is: FILE1 has Real values and FILE2 has Imaginary values. */
/* Use this data to transform/map (Real,Imaginary ) -> (Amplitude,Phase)
   values; then map (Amp,Phs) -> (Intensity,Hue), that is,
   (amp_data,phs_data) */
        map_re_im_2_amp_phs(&raw_chan1, &raw_chan2);
        data_to_16bit(&conv_amp_data, &conv_phs_data);
        plot_huei();
        break;
        
    case IM_RE:
/* Raw Data Form is: FILE1 has Imaginary values and FILE2 has Real values. */
/* Use this data to transform/map (Imaginary,Real ) -> (Amplitude,Phase)
   values;   then map (Amp,Phs) -> (Intensity,Hue), that is,
   (amp_data,phs_data) */
      map_re_im_2_amp_phs(&raw_chan2, &raw_chan1);
      data_to_16bit(&conv_amp_data, &conv_phs_data);
      plot_huei();
      break;
    default:
      break;
  }
  
} /* End Function data_to_huei_pixmap */




void disp_cwedge_init_imag(void)

/* Displays a 256x256 colour-wedge pixel canvas; data values are drawn
   on a world-canvas (gives world co-ordinate layer on top of a pixel
   canvas for drawing) with the viewable image functionality of the
   karma graphics library. The wedge is used to give the user a feel
   for the full range of intensity and hue values.
   
   In addition, for the image pixel canvas: a world canvas is created;
   and it's viewable image initialized, yet not created or activated. */

{
  iarray cwedge;
  int i,j;
  KWorldCanvas cwedge_world_cnvs;

  ViewableImage cwedge_vimage;
  /* can be ignored - will be removed from karma in the future
     (default values are given by initialisation routine) */
  struct win_scale_type win_scale;
  const int cwedge_range = 256;
  

  /* initializations */

  /* scale % slider values of hue, intensity and saturation
     for colourmap routine; the sliders allow the user to effectivly
     select a subspace of the full colour space to create the
     colourmap */
  
  start_hue =  (start_hue_val/100.0) * 6.0;
  end_hue = (end_hue_val/100.0) * 6.0;
  min_int = (min_int_val/100.0) * max_int;
  sat = (sat_val/100.0) * 1.0;
  
  
  /* get rgb colour masks for the graphics system/ display
     (different graphics systems will have different masks)
     for use in creating the colourmap */
  
  kwin_get_attributes(imag_pix_true_cnvs,
		      KWIN_ATT_IM_RED_MASK, &red_mask,
		      KWIN_ATT_IM_GREEN_MASK, &green_mask,
		      KWIN_ATT_IM_BLUE_MASK, &blue_mask,
		      KWIN_ATT_END);




/* Create a viewable image colourmap; to be shared by *all* application
   canvases. (cwedge and imag )*/
  
  /* allocate storage */
  cmap = kcmap_va_create (NULL, 65536, FALSE, NULL,
			  ( unsigned int (*) () ) NULL,
			  ( void (*) () ) NULL,
			  ( void (*) () ) NULL,
			  ( void (*) () ) NULL,
			  KCMAP_ATT_END);
  
  /* Get pointer to cmap storage, to be used for the cwedge in this case. */
  kcmap_get_pixels(cmap, &cmap_rgb_array);
  



/* create and initialise the cwedge (16bit index to cmap) */

  cwedge = iarray_create_2D(cwedge_range,cwedge_range,K_USHORT);
  for (i=0; i < cwedge_range; i++){
    for (j=0; j < cwedge_range; j++){
      US2(cwedge, i, j) =
        ( ((unsigned short int) i) << 8 ) ^ ( ((unsigned short int) j) );
    }
  }
  


  /* Create the RGB colours for the colour-map. This colour-map will
     reflect the users CURRENT choise of: min/max hue, min intensity,
     and saturation.  */
  col_hsb_slice_to_rgb_array(cmap_rgb_array,red_mask,green_mask,blue_mask,
			     min_int,max_int,start_hue,end_hue,sat);  

  /* register the cmap with the viewable images package */
  kcmap_notify_pixels_changed (cmap);
  



/* Create the world canvas from the pixel canvas and initialize the
   structure that handles the specification of colours for out of
   bounds values, win_scale. Both colour-wedge and image world canvases
   are created. */
  
  canvas_init_win_scale (&win_scale, K_WIN_SCALE_MAGIC_NUMBER);
  cwedge_world_cnvs = canvas_create (cwedge_pix_true_cnvs, cmap,
				     &win_scale);
  imag_world_cnvs = canvas_create (imag_pix_true_cnvs, cmap,
                                   &win_scale);
  /*  Set the intensity scale manually and later turn off automatic intensity
      scaling since it is not useful  */
  canvas_set_attributes (imag_world_cnvs,
			 CANVAS_ATT_VALUE_MIN, 0.0,
			 CANVAS_ATT_VALUE_MAX, 65535.0,
			 CANVAS_ATT_END);
  
/* Create and display viewable image from the colour-wedge array, on a
 world canvas.  The viewable image for the image data is ONLY
 initilized, NOT created or displayed (activatied). */

  viewimg_init (cwedge_world_cnvs);
  viewimg_init (imag_world_cnvs);
  /* facilitate automatic zooming functions (drag zoom with mouse &
     unzoom with character u) */
  viewimg_create_drag_and_zoom_interface (imag_world_cnvs);
  viewimg_set_canvas_attributes(cwedge_world_cnvs,
				VIEWIMG_ATT_INT_X, FALSE,
				VIEWIMG_ATT_INT_Y, FALSE,
				VIEWIMG_ATT_MAINTAIN_ASPECT, FALSE,
				VIEWIMG_ATT_END);
  viewimg_set_canvas_attributes(imag_world_cnvs,
                                VIEWIMG_ATT_INT_X, FALSE,
                                VIEWIMG_ATT_INT_Y, FALSE,
                                VIEWIMG_ATT_MAINTAIN_ASPECT, FALSE,
				VIEWIMG_ATT_AUTO_V, FALSE,
                                VIEWIMG_ATT_END);
  cwedge_vimage = viewimg_create_from_iarray (cwedge_world_cnvs, cwedge,
					      FALSE);
  viewimg_make_active (cwedge_vimage);

  
}  /* End Function disp_cwedge_init_imag */






