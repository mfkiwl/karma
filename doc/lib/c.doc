/*  Link with:    -lkarma  */
/*  This file describes the c_ package of routines in the Karma library.

    These routines are meant to provide a general purpose callback management
    framework. Library packages and applications may use this package to
    implement their own callback mechanisms. This package removes the need for
    external code to maintain and traverse callback lists.


    Written by		Richard Gooch	24-Jan-1996

    Last updated by	Richard Gooch	24-Jan-1996


*/

KCallbackFunc c_register_callback (KCallbackList *list, flag (*callback) (),
				   void *object,
				   void *client1_data, flag client1_indirect,
				   void *client2_data, flag client2_indirect,
				   flag quenchable)
/*  [PURPOSE] This routine will register a function which should be called when
    the callbacks for an object should be called. When the object is destroyed
    a call should be made to  c_destroy_list  .The first callback registered is
    the first one called. Multiple callback functions may be registered per
    object.
    <list> A pointer to the callback list. This is changed. The initial value
    must be NULL.
    <callback> The function to be called when the object callbacks are called.
    The interface to this function is given below:
    [<pre>]
    flag callback (void *object, void *client1_data, void *call_data,
                   void *client2_data)
    *   [PURPOSE] This routine is called when object callbacks are called.
        <object> The object information pointer.
	<client1_data> The first client information pointer.
	<call_data> The call information pointer.
	<client2_data> The second client information pointer.
	[RETURNS] TRUE if further callbacks should not be called, else FALSE.
    *
    [</pre>]
    <object> The object pointer passed to the callback. This may be NULL.
    <client1_data> The first client information pointer passed to the callback.
    This may be NULL.
    <client1_indirect> If TRUE the callback is passed a pointer to the storage
    containing <<client1_data>>, else <<client1_data>> is passed directly to
    the callback.
    <client2_data> The second client information pointer passed to the callback
    This may be NULL.
    <client2_indirect> If TRUE the callback is passed a pointer to the storage
    containing <<client2_data>>, else <<client2_data>> is passed directly to
    the callback.
    <quenchable> If TRUE then the routine is permitted to quench calls to the
    following callbacks in the list.
    [RETURNS] A KCallbackFunc on success. On failure, the process aborts.
*/
/*---------------------------------------------------------------------------*/

void c_unregister_callback (KCallbackFunc callback)
/*  [PURPOSE] This routine will unregister a callback function.
    <callback> The callback function.
    [RETURNS] Nothing.
*/
/*---------------------------------------------------------------------------*/

flag c_call_callbacks (KCallbackList list, void *call_data)
/*  [PURPOSE] This routine will call all registered callbacks for an object.
    <list> The callback list.
    <call_data> The arbitrary call information pointer.
    [RETURNS] TRUE if one of the callbacks quenched the further delivery of
    callbacks, else FALSE.
*/
/*---------------------------------------------------------------------------*/

void c_destroy_list (KCallbackList list)
/*  [PURPOSE] This routine will unregister all callbacks for an object and then
    destroys the callback list.
    <list> The callback list.
    [RETURNS] Nothing.
*/
/*---------------------------------------------------------------------------*/
