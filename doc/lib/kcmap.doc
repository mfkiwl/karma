/*  Link with:    -lkarma  */
/*  This file describes the kcmap_ package of routines in the Karma
    library.

    These routines are meant to provide a high level mechanism to create and
    manipulate colourmaps, complete with colourmap sharing, dynamic allocation
    and event management.


    Written by		Richard Gooch	5-Dec-1995

    Last updated by	Richard Gooch	13-APR-1993


*/

Kcolourmap kcmap_va_create (char *name, unsigned int num_cells, flag tolerant,
			    Kdisplay dpy_handle, unsigned int (*alloc_func) (),
			    void (*free_func) (), void (*store_func) (),
			    void (*location_func) (), ...)
/*  [PURPOSE] This routine will create a high level colourmap.
    <name> The name of the function used to initialise the colour values. If
    this is NULL, the default "Greyscale1" function is used.
    <num_cells> The initial number of colourcells to allocate. This must not be
    less than 2.
    <tolerant> If TRUE the routine will try to allocate as many colourcells as
    possible (up to <<num_cells>>), else it will fail if it could not
    allocatate all required colourcells.
    <dpy_handle> The low level display handle. The meaning of this value
    depends on the lower level graphics library used.
    <alloc_func> The function which must be called in order to allocate
    colourcells. See the <xc_> routines for examples. The interface to this
    routine is as follows:
    [<pre>]
    unsigned int alloc_func (unsigned int num_cells,
                             unsigned long *pixel_values,
			     unsigned int min_cells, Kdisplay dpy_handle)
    *   [PURPOSE] This routine will allocate a number of colourcells in a low
        level colourmap (e.g. using the Xlib routine XAllocColorCells).
	<num_cells> The number of colourcells to allocate.
	<pixel_values> The array ofpixel values allocated will be written here.
	<min_cells> The minimum number of colourcells to allocate. The routine
	will try to allocate at least this number of colourcells.
	<dpy_handle> The low level display handle. The meaning of this value
	depends on the lower level graphics library used.
	[RETURNS] The number of colourcells allocated.
    *
    [</pre>]
    <free_func> The function which must be called to free colourcells. The
    interface to this routine is as follows:
    [<pre>]
    void free_func (unsigned int num_cells, unsigned long *pixel_values,
                    Kdisplay dpy_handle)
    *   [PURPOSE] This routine will free a number of colourcells in a low
        level colourmap.
	<num_cells> The number of colourcells to free.
	<pixel_values> The array of pixel values (colourcells) to free.
        <dpy_handle> The low level display handle. The meaning of this value
	depends on the lower level graphics library used.
	[RETURNS] Nothing.
    *
    [</pre>]
    <store_func> The function which is used to store colours into a low level
    colourmap. The interface to this routine is as follows:
    [<pre>]
    void store_func (unsigned int num_cells, unsigned long *pixel_values,
                     unsigned short *reds, unsigned short *greens,
		     unsigned short *blues, unsigned int stride,
		     Kdisplay dpy_handle)
    *   [PURPOSE] This routine will store colours into a low level colourmap.
        <num_cells> The number of colourcells to store.
	<pixel_values> The array of pixel values.
	<reds> The array of red intensity values.
	<greens> The array of green intensity values.
	<blues> The array of blue intensity values.
	<stride> The stride (in unsigned shorts) between intensity values in
	each array.
	<dpy_handle> The low level display handle. The meaning of this value
	depends on the lower level graphics library used.
	[RETURNS] Nothing.
    *
    [</pre>]
    <location_func> The function which is used to determine the location of a
    display. The interface to this routine is as follows:
    [<pre>]
    void location_func (Kdisplay dpy_handle, unsigned long *serv_hostaddr,
                        unsigned long *serv_display_num)
    *   [PURPOSE] This routine will determine the location of the graphics
        display being used.
	<dpy_handle> The low level display handle. The meaning of this value
	depends on the lower level graphics library used.
	<serv_hostaddr> The Internet address of the host to which the display
	is connected will be written here.
	<serv_display_num> The number of the display will be written here.
	[RETURNS] Nothing.
    *
    [</pre>]
    [NOTE] If the above routines are NULL, the colourmap created is assumed to
    be a software colourmap, otherwise it is considered to be a
    hardware/virtual colourmap.
    [VARARGS] The optional list of parameter attribute-key attribute-value
    pairs must follow. This list must be terminated with the value
    KCMAP_ATT_END.
    [RETURNS] A colourmap on success, else NULL.
*/
/*---------------------------------------------------------------------------*/

void kcmap_add_RGB_func (char *name, void (*func) (), unsigned int min_cells,
			 unsigned int max_cells)
/*  This routine will register a named function which will compute RGB
    intensity values for a colourmap. This function is typically called in
    response to a call to  kcmap_modify  .
    The name of the colourmap function must be pointed to by  name  .
    The function which is used to compute the RGB values must be pointed to by
    func  .
    The interface to this routine is as follows:

    void func (num_cells, reds, greens, blues, stride, x, y, var_param)
    *   This routine will write RGB colour intensity values to a number of
        colourcells. This routine is called in response to a call to
	kcmap_modify  .
        The number of colour cells to modify must be given by  num_cells  .
	The red intensity values must be pointed to by  reds  .
	The green intensity values must be pointed to by  greens  .
	The blue intensity values must be pointed to by  blues  .
	The stride (in unsigned shorts) between intensity values in each array
	must be given by  stride  .
	The parameters used to compute the colour values must be given by
	x  ,  y  and  var_param  .
	The routine returns nothing.
    *
    unsigned int num_cells;
    unsigned short *reds;
    unsigned short *greens;
    unsigned short *blues;
    unsigned int stride;
    double x;
    double y;
    void *var_param;

    The minimum number of colourcells that must be allocated for this function
    to work must be given by  min_cells  .If this is less than 2, no minimum is
    defined.
    The maximum number of colourcells that must be allocated for this function
    to work must be given by  max_cells  .If this is less than 2, no maximum is
    defined.
    The routine returns nothing.
*/
/*---------------------------------------------------------------------------*/

KCallbackFunc kcmap_register_resize_func (Kcolourmap cmap,
					  void (*resize_func) (), void *info)
/*  [PURPOSE] This routine will register a resize function for a high level
    colourmap. The resize function will be called whenever the colourmap is
    resized. If the colourmap is a software colourmap, the resize function is
    called whenever the colour values change.
    Many resize functions may be registered per colourmap. The first
    function registered is the first function called upon resize.
    <cmap> The colourmap.
    <resize_func> The function which is called when the colourmap is resized.
    The interface to this routine is as follows:
    [<pre>]
    void resize_func (Kcolourmap cmap, void **info)
    *   [PURPOSE] This routine registers a change in the size of a colourmap.
        <cmap> The colourmap.
	<info> A pointer to the arbitrary colourmap information pointer.
	[RETURNS] Nothing.
    *
    [</pre>]
    <info> The initial arbitrary colourmap information pointer.
    [RETURNS] A KCallbackFunc object.
*/
/*---------------------------------------------------------------------------*/

flag kcmap_change (Kcolourmap cmap, char *new_name, unsigned int num_cells,
		   flag tolerant)
/*  This routine will change the active function (algorithm) used to calculate
    the colours in a colourmap and the size of the colourmap.
    The colourmap must be given by  cmap  .
    The new function name must be pointed to by  new_name  .If this is NULL
    then the active function is not changed.
    The number of colourcells required for the colourmap must be given by
    num_cells  .If this is less then 2 the number of cells is not changed.
    If the flag  tolerant  is TRUE, then the routine will try to allocate
    as many colourcells as possible (up to  num_cells  ), else it will
    fail if it could not allocatate all required colourcells.
    The routine returns TRUE on success, else it returns FALSE.
*/
/*---------------------------------------------------------------------------*/

void kcmap_modify (Kcolourmap cmap, double x, double y, void *var_param)
/*  This routine will call the active colour compute function to change the
    colourmap colours in a colourmap.
    The colourmap must be given by  cmap  .
    The parameters used to compute the colour values must be given by
    x  ,  y  and  var_param  .
    If the REVERSE attribute for the colourmap is set, the colourmap is
    reversed.
    The routine returns nothing.
*/
/*---------------------------------------------------------------------------*/

char **kcmap_list_funcs ()
/*  This routine will return a pointer to an array of supported colour function
    names. This array is dynamically allocated, and should be freed using
    m_free  .
    NOTE: the names in the array are statically allocated.
    The array is terminated with a NULL pointer.
*/
/*---------------------------------------------------------------------------*/

char *kcmap_get_active_func (Kcolourmap cmap)
/*  This routine will get the name of the active colour function for a
    colourmap.
    The colourmap must be given by  cmap  .
    The routine returns a pointer to the name of the colour function. This
    name must not be freed.
*/
/*---------------------------------------------------------------------------*/

unsigned int kcmap_get_pixels (Kcolourmap cmap, unsigned long **pixel_values)
/*  This routine will determine the number of colourcells in a colourmap.
    The colourmap must be given by  cmap  .
    The routine will write a pointer to the array of pixel values to the 
    storage pointed to by  pixel_values  .If this is NULL, nothing is written
    here.
    The routine returns the number of colourcells allocated.
*/
/*---------------------------------------------------------------------------*/

unsigned long kcmap_get_pixel (Kcolourmap cmap, unsigned int index)
/*  This routine will get a numbered pixel value from a colourmap.
    The colourmap must be given by  cmap  .
    The index of the pixel must be given by  index  .
    The routine returns the pixel value.
*/
/*---------------------------------------------------------------------------*/

void kcmap_prepare_for_slavery (Kcolourmap cmap)
/*  This routine will register a colourmap to be the choosen colourmap for
    subsequent attempts to open a slave colourmap connection.
    In order to make the colourmap a slave, a subsequent call to
    conn_attempt_connection  must be made.
    The colourmap must be given by  cmap  .
    The routine returns nothing.
*/
/*---------------------------------------------------------------------------*/

flag kcmap_copy_to_struct (Kcolourmap cmap, packet_desc **top_pack_desc,
			   char **top_packet)
/*  This routine will copy the colour data in a colourmap into a newly
    allocated Karma data structure. This data structure may be subsequently
    deallocated.
    The colourmap must be given by  cmap  .
    The pointer to the top level packet descriptor that is allocated will be
    written to the storage pointed to by  top_pack_desc  .
    The pointer to the top level packet that is allocated will be written to
    the storage pointed to by  top_packet  .
    The routine returns TRUE on success, else it returns FALSE.
*/
/*---------------------------------------------------------------------------*/

flag kcmap_copy_from_struct (Kcolourmap cmap, packet_desc *top_pack_desc,
			     char *top_packet)
/*  This routine will copy the colour data in a Karma data structure into a
    colourmap. If the colourmap changes size, then the  resize_func  registered
    is called.
    The colourmap must be given by  cmap  .
    The top level packet descriptor must be pointed to by  top_pack_desc  .
    The top level packet must be pointed to by  top_packet  .
    The routine returns TRUE on success, else it returns FALSE.
*/
/*---------------------------------------------------------------------------*/

unsigned short *kcmap_get_rgb_values (Kcolourmap cmap, unsigned int *size)
/*  This routine will return the RGB values in a colourmap. The colour values
    are arranged in packets of Red, Green and Blue values.
    The colourmap must be given by  cmap  .
    The routine will write the size of the colourmap to the storage pointed to
    by  size  .
    The routine returns a pointer to a dynamically allocated array. This must
    be freed with  m_free  .
    On failure it returns NULL.
*/
/*---------------------------------------------------------------------------*/

void kcmap_get_attributes (Kcolourmap cmap, ...)
/*  [PURPOSE] This routine will get the attributes for a colourmap.
    <cmap> The colourmap.
    [VARARGS] The optional list of parameter attribute-key attribute-value
    pairs must follow. This list must be terminated with the value
    KCMAP_ATT_END.
    [RETURNS] Nothing.
*/
/*---------------------------------------------------------------------------*/

void kcmap_set_attributes (Kcolourmap cmap, ...)
/*  [PURPOSE] This routine will set the attributes for a colourmap.
    <cmap> The colourmap.
    [VARARGS] The optional list of parameter attribute-key attribute-value
    pairs must follow. This list must be terminated with the value
    KCMAP_ATT_END.
    [NOTE] The colourmap is not recomputed: the effect is delayed.
    [RETURNS] Nothing.
*/
/*---------------------------------------------------------------------------*/
